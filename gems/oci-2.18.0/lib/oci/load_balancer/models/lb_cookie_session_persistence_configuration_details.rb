# Copyright (c) 2016, 2022, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

require 'date'

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # The configuration details for implementing load balancer cookie session persistence (LB cookie stickiness).
  #
  # Session persistence enables the Load Balancing service to direct all requests that originate from a single logical
  # client to a single backend web server. For more information, see
  # [Session Persistence](https://docs.cloud.oracle.com/Content/Balance/Reference/sessionpersistence.htm).
  #
  # When you configure LB cookie stickiness, the load balancer inserts a cookie into the response. The parameters configured
  # in the cookie enable session stickiness. This method is useful when you have applications and Web backend services
  # that cannot generate their own cookies.
  #
  # Path route rules take precedence to determine the target backend server. The load balancer verifies that session stickiness
  # is enabled for the backend server and that the cookie configuration (domain, path, and cookie hash) is valid for the
  # target. The system ignores invalid cookies.
  #
  # To disable LB cookie stickiness on a running load balancer, use the
  # {#update_backend_set update_backend_set} operation and specify `null` for the
  # `LBCookieSessionPersistenceConfigurationDetails` object.
  #
  # Example: `LBCookieSessionPersistenceConfigurationDetails: null`
  #
  # **Note:** `SessionPersistenceConfigurationDetails` (application cookie stickiness) and `LBCookieSessionPersistenceConfigurationDetails`
  # (LB cookie stickiness) are mutually exclusive. An error results if you try to enable both types of session persistence.
  #
  # **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
  #
  class LoadBalancer::Models::LBCookieSessionPersistenceConfigurationDetails
    # The name of the cookie inserted by the load balancer. If this field is not configured, the cookie name defaults
    # to \"X-Oracle-BMC-LBS-Route\".
    #
    # Example: `example_cookie`
    #
    # **Notes:**
    #
    # *  Ensure that the cookie name used at the backend application servers is different from the cookie name used
    #    at the load balancer. To minimize the chance of name collision, Oracle recommends that you use a prefix
    #    such as \"X-Oracle-OCI-\" for this field.
    #
    # *  If a backend server and the load balancer both insert cookies with the same name, the client or browser
    #    behavior can vary depending on the domain and path values associated with the cookie. If the name, domain,
    #    and path values of the `Set-cookie` generated by a backend server and the `Set-cookie` generated by the
    #    load balancer are all the same, the client or browser treats them as one cookie and returns only one of
    #    the cookie values in subsequent requests. If both `Set-cookie` names are the same, but the domain and path
    #    names are different, the client or browser treats them as two different cookies.
    #
    # @return [String]
    attr_accessor :cookie_name

    # Whether the load balancer is prevented from directing traffic from a persistent session client to
    # a different backend server if the original server is unavailable. Defaults to false.
    #
    # Example: `false`
    #
    # @return [BOOLEAN]
    attr_accessor :disable_fallback

    # The domain in which the cookie is valid. The `Set-cookie` header inserted by the load balancer contains a
    # domain attribute with the specified value.
    #
    # This attribute has no default value. If you do not specify a value, the load balancer does not insert the domain
    # attribute into the `Set-cookie` header.
    #
    # **Notes:**
    #
    # *  [RFC 6265 - HTTP State Management Mechanism](https://www.ietf.org/rfc/rfc6265.txt) describes client and
    #    browser behavior when the domain attribute is present or not present in the `Set-cookie` header.
    #
    #    If the value of the `Domain` attribute is `example.com` in the `Set-cookie` header, the client includes
    #    the same cookie in the `Cookie` header when making HTTP requests to `example.com`, `www.example.com`, and
    #    `www.abc.example.com`. If the `Domain` attribute is not present, the client returns the cookie only for
    #    the domain to which the original request was made.
    #
    # *  Ensure that this attribute specifies the correct domain value. If the `Domain` attribute in the `Set-cookie`
    #    header does not include the domain to which the original request was made, the client or browser might reject
    #    the cookie. As specified in RFC 6265, the client accepts a cookie with the `Domain` attribute value `example.com`
    #    or `www.example.com` sent from `www.example.com`. It does not accept a cookie with the `Domain` attribute
    #    `abc.example.com` or `www.abc.example.com` sent from `www.example.com`.
    #
    # Example: `example.com`
    #
    # @return [String]
    attr_accessor :domain

    # The path in which the cookie is valid. The `Set-cookie header` inserted by the load balancer contains a `Path`
    # attribute with the specified value.
    #
    # Clients include the cookie in an HTTP request only if the path portion of the request-uri matches, or is a
    # subdirectory of, the cookie's `Path` attribute.
    #
    # The default value is `/`.
    #
    # Example: `/example`
    #
    # @return [String]
    attr_accessor :path

    # The amount of time the cookie remains valid. The `Set-cookie` header inserted by the load balancer contains
    # a `Max-Age` attribute with the specified value.
    #
    # The specified value must be at least one second. There is no default value for this attribute. If you do not
    # specify a value, the load balancer does not include the `Max-Age` attribute in the `Set-cookie` header. In
    # most cases, the client or browser retains the cookie until the current session ends, as defined by the client.
    #
    # Example: `3600`
    #
    # @return [Integer]
    attr_accessor :max_age_in_seconds

    # Whether the `Set-cookie` header should contain the `Secure` attribute. If `true`, the `Set-cookie` header
    # inserted by the load balancer contains the `Secure` attribute, which directs the client or browser to send the
    # cookie only using a secure protocol.
    #
    # **Note:** If you set this field to `true`, you cannot associate the corresponding backend set with an HTTP
    # listener.
    #
    # Example: `true`
    #
    # @return [BOOLEAN]
    attr_accessor :is_secure

    # Whether the `Set-cookie` header should contain the `HttpOnly` attribute. If `true`, the `Set-cookie` header
    # inserted by the load balancer contains the `HttpOnly` attribute, which limits the scope of the cookie to HTTP
    # requests. This attribute directs the client or browser to omit the cookie when providing access to cookies
    # through non-HTTP APIs. For example, it restricts the cookie from JavaScript channels.
    #
    # Example: `true`
    #
    # @return [BOOLEAN]
    attr_accessor :is_http_only

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        # rubocop:disable Style/SymbolLiteral
        'cookie_name': :'cookieName',
        'disable_fallback': :'disableFallback',
        'domain': :'domain',
        'path': :'path',
        'max_age_in_seconds': :'maxAgeInSeconds',
        'is_secure': :'isSecure',
        'is_http_only': :'isHttpOnly'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        # rubocop:disable Style/SymbolLiteral
        'cookie_name': :'String',
        'disable_fallback': :'BOOLEAN',
        'domain': :'String',
        'path': :'String',
        'max_age_in_seconds': :'Integer',
        'is_secure': :'BOOLEAN',
        'is_http_only': :'BOOLEAN'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:disable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    # @option attributes [String] :cookie_name The value to assign to the {#cookie_name} property
    # @option attributes [BOOLEAN] :disable_fallback The value to assign to the {#disable_fallback} property
    # @option attributes [String] :domain The value to assign to the {#domain} property
    # @option attributes [String] :path The value to assign to the {#path} property
    # @option attributes [Integer] :max_age_in_seconds The value to assign to the {#max_age_in_seconds} property
    # @option attributes [BOOLEAN] :is_secure The value to assign to the {#is_secure} property
    # @option attributes [BOOLEAN] :is_http_only The value to assign to the {#is_http_only} property
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      self.cookie_name = attributes[:'cookieName'] if attributes[:'cookieName']

      raise 'You cannot provide both :cookieName and :cookie_name' if attributes.key?(:'cookieName') && attributes.key?(:'cookie_name')

      self.cookie_name = attributes[:'cookie_name'] if attributes[:'cookie_name']

      self.disable_fallback = attributes[:'disableFallback'] unless attributes[:'disableFallback'].nil?
      self.disable_fallback = false if disable_fallback.nil? && !attributes.key?(:'disableFallback') # rubocop:disable Style/StringLiterals

      raise 'You cannot provide both :disableFallback and :disable_fallback' if attributes.key?(:'disableFallback') && attributes.key?(:'disable_fallback')

      self.disable_fallback = attributes[:'disable_fallback'] unless attributes[:'disable_fallback'].nil?
      self.disable_fallback = false if disable_fallback.nil? && !attributes.key?(:'disableFallback') && !attributes.key?(:'disable_fallback') # rubocop:disable Style/StringLiterals

      self.domain = attributes[:'domain'] if attributes[:'domain']

      self.path = attributes[:'path'] if attributes[:'path']

      self.max_age_in_seconds = attributes[:'maxAgeInSeconds'] if attributes[:'maxAgeInSeconds']

      raise 'You cannot provide both :maxAgeInSeconds and :max_age_in_seconds' if attributes.key?(:'maxAgeInSeconds') && attributes.key?(:'max_age_in_seconds')

      self.max_age_in_seconds = attributes[:'max_age_in_seconds'] if attributes[:'max_age_in_seconds']

      self.is_secure = attributes[:'isSecure'] unless attributes[:'isSecure'].nil?
      self.is_secure = true if is_secure.nil? && !attributes.key?(:'isSecure') # rubocop:disable Style/StringLiterals

      raise 'You cannot provide both :isSecure and :is_secure' if attributes.key?(:'isSecure') && attributes.key?(:'is_secure')

      self.is_secure = attributes[:'is_secure'] unless attributes[:'is_secure'].nil?
      self.is_secure = true if is_secure.nil? && !attributes.key?(:'isSecure') && !attributes.key?(:'is_secure') # rubocop:disable Style/StringLiterals

      self.is_http_only = attributes[:'isHttpOnly'] unless attributes[:'isHttpOnly'].nil?
      self.is_http_only = true if is_http_only.nil? && !attributes.key?(:'isHttpOnly') # rubocop:disable Style/StringLiterals

      raise 'You cannot provide both :isHttpOnly and :is_http_only' if attributes.key?(:'isHttpOnly') && attributes.key?(:'is_http_only')

      self.is_http_only = attributes[:'is_http_only'] unless attributes[:'is_http_only'].nil?
      self.is_http_only = true if is_http_only.nil? && !attributes.key?(:'isHttpOnly') && !attributes.key?(:'is_http_only') # rubocop:disable Style/StringLiterals
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:enable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines


    # Checks equality by comparing each attribute.
    # @param [Object] other the other object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        cookie_name == other.cookie_name &&
        disable_fallback == other.disable_fallback &&
        domain == other.domain &&
        path == other.path &&
        max_age_in_seconds == other.max_age_in_seconds &&
        is_secure == other.is_secure &&
        is_http_only == other.is_http_only
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines

    # @see the `==` method
    # @param [Object] other the other object to be compared
    def eql?(other)
      self == other
    end

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [cookie_name, disable_fallback, domain, path, max_age_in_seconds, is_secure, is_http_only].hash
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            public_method("#{key}=").call(
              attributes[self.class.attribute_map[key]]
                .map { |v| OCI::Internal::Util.convert_to_type(Regexp.last_match(1), v) }
            )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          public_method("#{key}=").call(
            OCI::Internal::Util.convert_to_type(type, attributes[self.class.attribute_map[key]])
          )
        end
        # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = public_method(attr).call
        next if value.nil? && !instance_variable_defined?("@#{attr}")

        hash[param] = _to_hash(value)
      end
      hash
    end

    private

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
